// исходный текст программы сохранен в кодировке UTF-8 с сигнатурой

// verylong.cpp
// реализация (определения методов) класса очень длинных целых чисел

#include "verylong.h" // заголовочный файл с описателем класса очень длинных целых чисел

// вывод очень длинного целого числа на экран
void verylong::putvl() const
{
	wchar_t temp[SZ];
	wcscpy(temp, vlstr);                 // делаем копию нашего числа в строке
	if (!sign && cmp(verylong(0L)) != 2) // если число отрицательное и не равно 0,
		wcout << L'-';                   // выведем перед ним знак минуса
	wcout << _wcsrev(temp);              // разворачиваем его и выводим на экран
}

// получение числа от пользователя
void verylong::getvl()
{
	wchar_t temp[SZ];
	wcin >> temp;         // получаем строку с числом от пользователя

	// предполагается, что если число отрицательное, пользователь введет перед
	// ним знак минуса '-', если же число положительное, пользователь должен сразу
	// же начать с цифр, то есть знак плюса '+' вводиться не должен
	if (temp[0] == L'-')  // получим знак числа
		{ sign = false; wcscpy(vlstr, temp + 1); }
	else
		{ sign = true; wcscpy(vlstr, temp); }
	
	vlen = wcslen(vlstr); // найдем длину полученного числа
	_wcsrev(vlstr);       // разворачиваем число
}

// найти сумму очень длинных целых чисел
verylong verylong::operator+ (const verylong v)
{
	verylong res;

	if (sign && v.sign)            // если оба слагаемых положительны
	{
		res = natural_addition(v); // складываем их модули
		res.sign = true;           // сумма — положительна
	}
	else if (!sign && !v.sign)     // если оба слагаемых отрицательны
	{
		res = natural_addition(v); // складываем их модули
		res.sign = false;          // сумма — отрицательна
	}
	else                           // если одно из слагаемых отрицательно
	{
		if (cmp(v) == 1)                  // если первое слагаемое больше,
		{
			res = natural_subtraction(v);       // считаем разность первого и второго слагаемых
			res.sign = sign;                    // знак результата — знак большего слагаемого
		}
		else if (cmp(v) == 0)             // если второе слагаемое больше,
		{
			res = v.natural_subtraction(*this); // считаем разность второго и первого слагаемых
			res.sign = v.sign;                  // знак результата — знак большего слагаемого
		}
		else                              // слагаемые равны
			res = verylong(0L);                 // результат равен 0
	}
	
	return res;
}

// найти разность очень длинных целых чисел
verylong verylong::operator- (const verylong v)
{
	verylong res;

	if (sign && !v.sign)           // если уменьшаемое положительно, а вычитаемое отрицательно
	{                              //     то есть получается сложение: a – (–b) = a + b
		res = natural_addition(v); // складываем их модули
		res.sign = true;           // итог — положителен
	}
	else if (!sign && v.sign)      // если уменьшаемое отрицательно, а вычитаемое положительно
	{                              //     то есть получается: –a – b = –(a + b)
		res = natural_addition(v); // складываем их модули
		res.sign = false;          // итог — отрицателен
	}
	else                           // если уменьшаемое и вычитаемое имеют один и тот же знак
	{
		if (cmp(v) == 1)                  // если уменьшаемое больше,
		{
			res = natural_subtraction(v);       // считаем разницу уменьшаемого и вычитаемого
			res.sign = sign;                    // знак результата — знак уменьшаемого
			                                    // (или знак вычитаемого, они же тут равны)
		}
		else if (cmp(v) == 0)             // если вычитаемое больше,
		{
			res = v.natural_subtraction(*this); // считаем разницу вычитаемого и уменьшаемого
			res.sign = !v.sign;                 // знак результата — знак, противоположный
			                                    // знаку уменьшаемого (или вычитаемого, они равны)
		}
		else                              // уменьшаемое и вычитаемое равны
			res = verylong(0L);                 // результат равен 0
	}

	return res;
}

// натуральное сложение: находим сумму двух положительных очень длинных целых чисел,
// то есть итог сложения тоже будет положительным очень длинным целым числом
// (сумма двух натуральных чисел дает натуральное число)
verylong verylong::natural_addition(const verylong v) const
{
	wchar_t temp[SZ];
	int j;
	// получим длину более длинного слагаемого
	int maxlen = (vlen > v.vlen) ? vlen : v.vlen;
	int carry = 0;                         // перенос станет равен 1,
	                                       // если сумма разрядов будет >= 10
	for (j = 0; j < maxlen; j++)           // начать цикл поразрядного сложения
	{
		int d1 = (j > vlen - 1) ? 0 : vlstr[j] - L'0';     // получим цифру 1-го слагаемого
		int d2 = (j > v.vlen - 1) ? 0 : v.vlstr[j] - L'0'; // получим цифру 2-го слагаемого
		int digitsum = d1 + d2 + carry;    // суммируем цифры и перенос
		if (digitsum >= 10)                // если сумма цифр >= 10, то выполнить перенос
			{ digitsum -= 10; carry = 1; } // уменьшим сумму на 10 и установим перенос
		else
			carry = 0;                     // иначе переноса нет, он равен нулю
		temp[j] = digitsum + L'0';         // преобразуем цифру в символ и помещаем в итог
	}
	if (carry == 1)                        // если остался перенос от последнего сложения,
		temp[j++] = L'1';                  // добавляем еще один старший разряд, равный 1
	temp[j] = L'\0';                       // обозначим конец строки нулевым символом

	// вставим удаление ведущих нулей на всякий случай
	for (j = wcslen(temp) - 1; j > 0; j--)
	{
		if (temp[j] == L'0')               // если разряд содержит 0,
			temp[j] = L'\0';               // сократить наше число на этот разряд
										   // и перейти к проверке следующего разряда
		else
			break;                         // иначе выйти из цикла
	}

	return verylong(temp);                 // возвратим результат сложения
}

// натуральное вычитание: находим разницу двух положительных очень длинных целых чисел,
// при этом должно выполняться условие: первое из этих чисел больше второго или равно ему,
// то есть итог вычитания тоже будет положительным очень длинным целым числом
// (разница двух натуральных чисел дает натуральное число, если уменьшаемое больше
// вычитаемого или равно ему)
verylong verylong::natural_subtraction(const verylong v) const
{
	wchar_t temp[SZ];
	int j;
	int carry = 0;                         // перенос из старшего разряда

	for (j = 0; j < vlen; j++)             // начать цикл поразрядного вычитания
	{
		int d1 = vlstr[j] - L'0';                          // получим цифру уменьшаемого
		int d2 = (j > v.vlen - 1) ? 0 : v.vlstr[j] - L'0'; // получим цифру вычитаемого
		int digitres = d1 - d2 - carry;    // вычисляем разность этих цифр
		                                   // с учетом переноса
		if (digitres < 0)                  // если разность < 0, то выполнить перенос
			{ digitres += 10; carry = 1; } // увеличим разность на 10 и установим перенос
		else
			carry = 0;                     // иначе переноса нет, он равен нулю
		temp[j] = digitres + L'0';         // преобразуем цифру в символ и помещаем в итог
	}
	temp[j] = L'\0';                       // обозначим конец строки нулевым символом

	// тут в temp уже содержится результат вычитания, но в этом результате могут
	// быть ведущие нули; например, при вычислении разницы 1000 и 999 в temp
	// будет записано число 1 в виде строки "1000" (помним, что числа мы храним в
	// "перевернутом" виде), то есть с тремя ведущими нулями; поэтому здесь
	// напишем удаление этих ведущих нулей, если они есть в результате

	// ведем проверку от старшего к младшему разряду,
	// младший разряд (j == 0) проверять не будем, так как в числе должен остаться
	// хотя бы один разряд
	for (j = vlen - 1; j > 0; j--)
	{
		if (temp[j] == L'0')               // если разряд содержит 0,
			temp[j] = L'\0';               // сократить наше число на этот разряд
		                                   // и перейти к проверке следующего разряда
		else
			break;                         // иначе выйти из цикла
	}

	return verylong(temp);                 // возвратим результат вычитания
}

// если текущее число больше аргумента, то возвращается 1, если меньше — 0,
// при равенстве возвращается 2 (сравниваются модули чисел, без учета знаков)
int verylong::cmp(const verylong v) const
{
	if (vlen > v.vlen)      // кол-во разрядов текущего числа больше, чем у аргумента
		return 1;
	else if (vlen < v.vlen) // кол-во разрядов текущего числа меньше, чем у аргумента
		return 0;
	else                                    // при равном кол-ве разрядов
		for (int j = vlen - 1; j >= 0; j--) // сравним числа поразрядно,
		{                                   // начиная со старшего разряда
			if (vlstr[j] - L'0' > v.vlstr[j] - L'0')
				return 1;
			else if (vlstr[j] - L'0' < v.vlstr[j] - L'0')
				return 0;
			// если разряды равны, переходим к сравнению более младших разрядов
		}
	// если числа равны, то
	return 2;
}

// найти произведение очень длинных целых чисел
verylong verylong::operator* (const verylong v)
{
	verylong res;

	res = natural_multiplication(v);            // находим произведение модулей сомножителей
	if ((sign && v.sign) || (!sign && !v.sign)) // если сомножители имеют одинаковые знаки,
		res.sign = true;                        // итог — положителен
	else                                        // если сомножители имеют разные знаки,
		res.sign = false;                       // итог — отрицателен

	return res;
}

// натуральное умножение очень длинных целых чисел
verylong verylong::natural_multiplication(const verylong v) const
{
	verylong pprod;                        // произведение цифр из одного разряда
	verylong tempsum;                      // текущая сумма произведений
	for (int j = 0; j < v.vlen; j++)       // переберем цифры из разрядов множителя
	{
		int digit = v.vlstr[j] - L'0';     // получим цифру множителя
		pprod = multdigit(digit);          // умножим множимое на эту цифру
		for (int k = 0; k < j; k++)        // умножим результат на 10
			pprod = mult10(pprod);         // нужное количество (k) раз
		tempsum = tempsum + pprod;         // добавить очередное произведение к итоговой сумме
	}
	return tempsum;                        // возвратим результат умножения
}

// найти результат целочисленного деления очень длинных целых чисел
verylong verylong::operator/ (const verylong v)
{
	verylong res;

	res = natural_division(v, true);            // находим результат деления модулей
	                                            // делимого и делителя
	if ((sign && v.sign) || (!sign && !v.sign)) // если делимое и делитель имеют одинаковые знаки,
		res.sign = true;                        // итог — положителен
	else                                        // если делимое и делитель имеют разные знаки,
		res.sign = false;                       // итог — отрицателен

	return res;
}

// найти остаток от целочисленного деления очень длинных целых чисел
verylong verylong::operator% (const verylong v)
{
	verylong res;
	
	if (cmp(verylong(0L)) == 2)           // если делимое равно 0
		res = verylong(0L);               // остаток от деления равен 0
	else
	{                                     // если делимое не равно 0
		res = natural_division(v, false); // находим остаток от деления модулей
		                                  // делимого и делителя
		res.sign = sign;                  // знак остатка равен знаку делимого
	}

	return res;
}

// натуральное целочисленное деление: возвращает результат целочисленного деления, либо остаток,
// в зависимости от значения аргумента flag: true — результат, false — остаток
// (слово «натуральное» здесь означает, что делимое и делитель — положительные числа)
verylong verylong::natural_division(const verylong v, bool flag) const
{	
	if (v.cmp(verylong(0L)) == 2)          // если делитель равен 0
	{
		wcout << L"\nОшибка! Делитель не может быть равен нулю!" << endl;
		exit(1);                           // завершить программу
	}

	if (v.cmp(*this) == 1)                    // если делитель больше делимого
		return (flag) ? verylong(0L) : *this; // завершить работу метода и
	                                          // возвратить результат деления: 0
	                                          // остаток от деления: делимое

	                                       // если делитель меньше делимого или равен ему
	wchar_t res[SZ];
	verylong dividend, divider;
	int j = 0;

	dividend = *this;
	divider = v;

	dividend.sign = true; // так как это натуральное деление, производим его
	divider.sign = true;  // без учета знаков делимого и делителя

	do {                                   // цикл, пока делитель меньше делимого или равен ему

		// умножаем делитель на 10, пока он не приблизится к делимому как можно ближе
		verylong prevdiv;
		while (divider.cmp(dividend) == 0 || divider.cmp(dividend) == 2)
		{
			prevdiv = divider;
			divider = mult10(divider);
		}
		divider = prevdiv;

		// умножаем делитель на числа от 1 до 9, пока он не приблизится к делимому как можно ближе,
		// при этом это число в пределах от 1 до 9 станет очередной цифрой итогового ответа
		int digit = 1;
		while (divider.cmp(dividend) == 0 || divider.cmp(dividend) == 2)
		{
			digit++;
			divider = prevdiv.multdigit(digit);
		}
		digit--;
		divider = prevdiv.multdigit(digit);

		// запишем найденную цифру ответа в итог
		res[j++] = digit + L'0';

		// отнимем от делимого отработанную часть
		dividend = dividend - divider;
		
		// вернем делитель к первоначальному значению
		divider = v;

	} while (divider.cmp(dividend) == 0 || divider.cmp(dividend) == 2);

	res[j] = L'\0';                           // конец строки
	_wcsrev(res);                             // перевернем итог
	return (flag) ? verylong(res) : dividend; // возвратим результат или остаток
}

// умножение аргумента на 10
verylong verylong::mult10(const verylong v) const
{
	wchar_t temp[SZ];
	for (int j = v.vlen - 1; j >= 0; j--)  // сдвинем цифры в массиве-строке
		temp[j + 1] = v.vlstr[j];          // на одну позицию вправо
	temp[0] = L'0';                        // поместим ноль в освободившуюся позицию слева
	temp[v.vlen + 1] = L'\0';              // обозначим конец строки
	return verylong(temp);                 // возвратим результат
}

// умножение текущего числа на аргумент-цифру
verylong verylong::multdigit(const int d2) const
{
	wchar_t temp[SZ];
	int j, carry = 0;
	for (j = 0; j < vlen; j++)             // переберем цифры текущего числа
	{
		int d1 = vlstr[j] - L'0';          // получим цифру текущего числа
		int digitprod = d1 * d2;           // умножим ее на аргумент-цифру
		digitprod += carry;                // прибавим к произведению перенос
		if (digitprod >= 10)               // если результат >= 10, организуем перенос
		{
			carry = digitprod / 10;        // перенос равен цифре из старшего разряда
			digitprod -= carry * 10;       // текущий результат — цифра из младшего разряда
		}
		else
			carry = 0;                     // иначе перенос равен нулю (переноса нет)
		temp[j] = digitprod + L'0';        // преобразуем цифру в символ и помещаем в итог
	}
	if (carry != 0)                        // если остался перенос от последнего произведения,
		temp[j++] = carry + L'0';          // добавляем еще один старший разряд с переносом
	temp[j] = L'\0';                       // обозначим конец строки
	return verylong(temp);                 // возвратим результат
}