// исходный текст программы сохранен в кодировке UTF-8 с сигнатурой

// verylong.cpp
// реализация (определения методов) класса очень длинных целых чисел

#include "verylong.h" // заголовочный файл с описателем класса очень длинных целых чисел

// вывод очень длинного целого числа на экран
void verylong::putvl() const
{
	wchar_t temp[SZ];
	wcscpy(temp, vlstr);    // делаем копию нашего числа в строке
	wcout << _wcsrev(temp); // разворачиваем его и выводим на экран
}

// получение числа от пользователя
void verylong::getvl()
{
	wcin >> vlstr;        // получаем строку с числом от пользователя
	vlen = wcslen(vlstr); // найдем длину полученного числа
	_wcsrev(vlstr);       // разворачиваем число
}

// найти сумму очень длинных целых чисел
verylong verylong::operator+ (const verylong v)
{
	wchar_t temp[SZ];
	int j;
	// получим длину более длинного слагаемого
	int maxlen = (vlen > v.vlen) ? vlen : v.vlen;
	int carry = 0;                         // перенос станет равен 1,
	                                       // если сумма разрядов будет >= 10
	for (j = 0; j < maxlen; j++)           // начать цикл поразрядного сложения
	{
		int d1 = (j > vlen - 1) ? 0 : vlstr[j] - L'0';     // получим цифру 1-го слагаемого
		int d2 = (j > v.vlen - 1) ? 0 : v.vlstr[j] - L'0'; // получим цифру 2-го слагаемого
		int digitsum = d1 + d2 + carry;    // суммируем цифры и перенос
		if (digitsum >= 10)                // если сумма цифр >= 10, то выполнить перенос
			{ digitsum -= 10; carry = 1; } // уменьшим сумму на 10 и установим перенос
		else
			carry = 0;                     // иначе переноса нет, он равен нулю
		temp[j] = digitsum + L'0';         // преобразуем цифру в символ и помещаем в итог
	}
	if (carry == 1)                        // если остался перенос от последнего сложения,
		temp[j++] = L'1';                  // добавляем еще один старший разряд, равный 1
	temp[j] = L'\0';                       // обозначим конец строки нулевым символом
	return verylong(temp);                 // возвратим результат сложения
}

// найти произведение очень длинных целых чисел
verylong verylong::operator* (const verylong v)
{
	verylong pprod;                        // произведение цифр из одного разряда
	verylong tempsum;                      // текущая сумма произведений
	for (int j = 0; j < v.vlen; j++)       // переберем цифры из разрядов множителя
	{
		int digit = v.vlstr[j] - L'0';     // получим цифру множителя
		pprod = multdigit(digit);          // умножим множимое на эту цифру
		for (int k = 0; k < j; k++)        // умножим результат на 10
			pprod = mult10(pprod);         // нужное количество (k) раз
		tempsum = tempsum + pprod;         // добавить очередное произведение к итоговой сумме
	}
	return tempsum;                        // возвратим результат умножения
}

// умножение аргумента на 10
verylong verylong::mult10(const verylong v) const
{
	wchar_t temp[SZ];
	for (int j = v.vlen - 1; j >= 0; j--)  // сдвинем цифры в массиве-строке
		temp[j + 1] = v.vlstr[j];          // на одну позицию вправо
	temp[0] = L'0';                        // поместим ноль в освободившуюся позицию слева
	temp[v.vlen + 1] = L'\0';              // обозначим конец строки
	return verylong(temp);                 // возвратим результат
}

// умножение текущего числа на аргумент-цифру
verylong verylong::multdigit(const int d2) const
{
	wchar_t temp[SZ];
	int j, carry = 0;
	for (j = 0; j < vlen; j++)             // переберем цифры текущего числа
	{
		int d1 = vlstr[j] - L'0';          // получим цифру текущего числа
		int digitprod = d1 * d2;           // умножим ее на аргумент-цифру
		digitprod += carry;                // прибавим к произведению перенос
		if (digitprod >= 10)               // если результат >= 10, организуем перенос
		{
			carry = digitprod / 10;        // перенос равен цифре из старшего разряда
			digitprod -= carry * 10;       // текущий результат — цифра из младшего разряда
		}
		else
			carry = 0;                     // иначе перенос равен нулю (переноса нет)
		temp[j] = digitprod + L'0';        // преобразуем цифру в символ и помещаем в итог
	}
	if (carry != 0)                        // если остался перенос от последнего произведения,
		temp[j++] = carry + L'0';          // добавляем еще один старший разряд с переносом
	temp[j] = L'\0';                       // обозначим конец строки
	return verylong(temp);                 // возвратим результат
}